<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Karth1kKumarK.github.io &middot; 
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/Advance_lane_Extraction_In_different_condition/public/css/poole.css">
  <link rel="stylesheet" href="/Advance_lane_Extraction_In_different_condition/public/css/syntax.css">
  <link rel="stylesheet" href="/Advance_lane_Extraction_In_different_condition/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/Advance_lane_Extraction_In_different_condition/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/Advance_lane_Extraction_In_different_condition/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-08">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/Advance_lane_Extraction_In_different_condition/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
    

    <!-- <a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a> -->
    <a class="sidebar-nav-item" href="https://github.com/Karth1kKumarK/Advance_lane_detection_code">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/Advance_lane_Extraction_In_different_condition/" title="Home">Karth1kKumarK.github.io</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <!-- <img src="ChessBoard_9x6.jpg"> -->
    <h1 class="post-title">
      <a href="/Advance_lane_Extraction_In_different_condition//2018/09/05/advance-lane.html">
        Extraction and Detection of Lanes in different illumination Condition
      </a>
    </h1>

    <span class="post-date">05 Sep 2018</span>

    <p>The first post <a href="https://karth1kkumark.github.io/Advance_lane_detection/" target="_blank">here</a>.Describes the lane detection using a color mask that has a major drawback. The Rpi camera that I am using has no IR filter, Therefore this greatly affects the color perception of the image based on illumination condition, This alters the color range of lane pixels, So the challenge was to develop a technique which is impervious to these drawbacks. This post describes the methodology to achieve lane extraction in various illumination condition with considerable accuracy.</p>

<p><img src="/Advance_lane_Extraction_In_different_condition/assets/images/IMG_0028.jpg" width="300px" /></p>

<h3 id="the-hardware-utlilized">The hardware Utlilized</h3>
<ul>
  <li>RC car</li>
  <li>RPI NOIR camera</li>
  <li>Raspiberry PI</li>
  <li>L298N motor driver</li>
</ul>

<h3 id="streaming-images-from-rpi-to-laptop-through-ros">Streaming Images from Rpi to Laptop Through ROS</h3>

<p>Ros has built-in packages for image streaming and control of a robot, which we will be using in the future. I have installed ubuntu mate flavor of Ubiquity robotics available  <a href="https://downloads.ubiquityrobotics.com/pi.html" target="_blank">here</a>, which has ros pre-installed. The instruction for compiling and running raspicam_node is available <a href="https://github.com/UbiquityRobotics/raspicam_node" target="_blank">available here.</a></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&lt;</span><span class="n">launch</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">node</span> <span class="nb">type</span><span class="o">=</span><span class="s">"raspicam_node"</span> <span class="n">pkg</span><span class="o">=</span><span class="s">"raspicam_node"</span> <span class="n">name</span><span class="o">=</span><span class="s">"raspicam_node"</span> <span class="n">output</span><span class="o">=</span><span class="s">"screen"</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"camera_info_url"</span> <span class="n">value</span><span class="o">=</span><span class="s">"package://raspicam_node/camera_info/camerav2_640X480.yaml"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"width"</span> <span class="n">value</span><span class="o">=</span><span class="s">"640"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"height"</span> <span class="n">value</span><span class="o">=</span><span class="s">"480"</span><span class="o">/&gt;</span>

<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"framerate"</span> <span class="n">value</span><span class="o">=</span><span class="s">"30"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"exposure_mode"</span> <span class="n">value</span><span class="o">=</span><span class="s">"antishake"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"shutter_speed"</span> <span class="n">value</span><span class="o">=</span><span class="s">"0"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">param</span> <span class="n">name</span><span class="o">=</span><span class="s">"camera_frame_id"</span> <span class="n">value</span><span class="o">=</span><span class="s">"raspicam"</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">node</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">launch</span><span class="o">&gt;</span></code></pre></figure>

<p>The image streamed by raspicam_node is in a compressed format. Hence rosrun the following to decompress and publish the image  on  <strong>/raspicam_node/image</strong> topic</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">rosrun</span> <span class="n">image_transport</span> <span class="n">republish</span> <span class="n">compressed</span> <span class="ow">in</span><span class="p">:</span><span class="o">=/</span><span class="n">raspicam_node</span><span class="o">/</span><span class="n">image</span> <span class="n">raw</span> <span class="n">out</span><span class="p">:</span><span class="o">=/</span><span class="n">raspicam_node</span><span class="o">/</span><span class="n">image</span></code></pre></figure>

<p>The image is published  on  the  <strong>/raspicam_node/image</strong> topic is of type sensor_msgs/Image. This need to be converted into opencv format for further operation.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">image_sub</span> <span class="o">=</span> <span class="n">rospy</span><span class="o">.</span><span class="n">Subscriber</span><span class="p">(</span><span class="s">"/raspicam_node/image"</span><span class="p">,</span><span class="n">Image</span><span class="p">,</span><span class="n">callback</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">cv_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bridge</span><span class="o">.</span><span class="n">imgmsg_to_cv2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">"bgr8"</span><span class="p">)</span></code></pre></figure>

<h3 id="preprocess-for-thresholding">Preprocess for thresholding</h3>
<p>The First step in the process of extraction of lane pixel is to undistort the image</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">undistorth</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">mtx</span><span class="p">,</span><span class="n">dist</span><span class="p">):</span><span class="c">#function for un distorting the image wrt to camera parameters </span>
                             <span class="c">#obtained from camera calibration</span>
        <span class="n">h</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
        <span class="n">newcameramtx</span><span class="p">,</span><span class="n">roi</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span> 
        <span class="n">dst</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">undistort</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">newcameramtx</span><span class="p">)</span>
        <span class="c">#plt.imshow(dst)</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">roi</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">w</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dst</span></code></pre></figure>

<p>Camera intrinsic matrix and distortion coefficient are passed as arguments  with the image.</p>

<p>In order to increase the contrast of the image, Adaptive histogram equalization is applied</p>

<table style="width:100%; border:0px;">
  <tr>
    <th>Undisort image</th>
    <th>Enhanced image</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/Undistort.png" width="480px" /></td>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/Enhancement_screenshot_07.09.2018.png" width="480px" /></td>
  </tr>
</table>
<div class="code-block"> 


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">enhancement</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>

<span class="c">#-----Converting image to LAB Color model----------------------------------- </span>
    <span class="n">lab</span><span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2LAB</span><span class="p">)</span>

<span class="c">#-----Splitting the LAB image to different channels-------------------------</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
    <span class="c">#cv2.imshow('l_channel', l)</span>
    <span class="c">#cv2.imshow('a_channel', a)</span>
    <span class="c">#cv2.imshow('b_channel', b)</span>

<span class="c">#-----Applying CLAHE to L-channel-------------------------------------------</span>
    <span class="n">clahe</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">createCLAHE</span><span class="p">(</span><span class="n">clipLimit</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">tileGridSize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">clahe</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="c">#cv2.imshow('CLAHE output', cl)</span>

<span class="c">#-----Merge the CLAHE enhanced L-channel with the a and b channel-----------</span>
    <span class="n">limg</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">merge</span><span class="p">((</span><span class="n">cl</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
    <span class="c">#cv2.imshow('limg', limg)</span>

<span class="c">#-----Converting image from LAB Color model to RGB model--------------------</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">limg</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_LAB2BGR</span><span class="p">)</span>
    <span class="c">#cv2.imshow('final', final)</span>
    <span class="c">#cv2.waitKey()</span>
    <span class="k">return</span> <span class="n">final</span></code></pre></figure>

</div>

<p>The contrast-enhanced image is converted to <a href="https://en.wikipedia.org/wiki/CIELAB_color_space" target="_blank">CIELAB color space.</a> The image is split into the corresponding channel(L* for the lightness and a* and b* for the greenâ€“red and blue-yellow color components). As the color of the track falls into blue-yellow, We choose b channel image(A) and apply the <strong>bitwise_not</strong> operation to obtain the inverse image(B). Now we subtract b channel image(A) from bit not image to obtain difference image C, Only those pixel which undergoes a change of more than 150-pixel value is retained .rest of the pixels are set to 0. The difference image(C) is element-wise multiplied with b channel image(A), This amplifies the pixel value of pixels which undergoes max change.</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>b channel image</th>
    <th>Bitnot image</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/B channel_screenshot_07.09.2018.png" width="480px" /></td>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/Bitnot_screenshot_07.09.2018.png" width="480px" /></td>
  </tr>
</table>

<table style="width:100%; border:0px;">
  <tr>
    <th>Difference image</th>
    <th>Element wise multipled image</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/Diff_screenshot_07.09.2018.png" width="480px" /></td>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/multipy_screenshot_07.09.2018.png" width="480px" /></td>
  </tr>
</table>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="n">lab</span><span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame11</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2LAB</span><span class="p">)</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
    <span class="n">bitnotimage</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">diff</span><span class="o">=</span><span class="n">bitnotimage</span><span class="o">-</span><span class="n">b</span>
    <span class="n">diff</span><span class="p">[</span><span class="n">diff</span><span class="o">&lt;</span> <span class="mi">150</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">multipyimage</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="n">multipyimage</span><span class="p">[</span><span class="n">multipyimage</span><span class="o">&lt;</span><span class="mi">110</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></code></pre></figure>

<h3 id="dynamic-thresholding">Dynamic Thresholding</h3>

<p>The implementation is inspired by this <a href="https://ieeexplore.ieee.org/document/6889285/" target="_blank">paper.</a> The image obtained from element-wise multiplication is applied dynamic thresholding to extract Lane pixel. Dynamic thresholding assumes that a vehicle runs in the middle of lanes. The image is divided in half along the width resulting in Dl(left half) and DR(right half) For both Dl and DR are scanned along the rows and max value in each row is obtained along with its position in the Row. For Dl the positional max value is selected as this resides closer to the middle of the lane, similarly, For DR the positional min value is selected.</p>

<table style="width:100%; border:0px;">
  <tr>
    <th>Element wise multipled image</th>
    <th>Dynamic Thresholding</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/multipy_screenshot_07.09.2018.png" width="480px" /></td>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/Dynamic thres_screenshot_07.09.2018.png" width="480px" /></td>
  </tr>
</table>

<div class="code-block"> 

<figure class="highlight"><pre><code class="language-python" data-lang="python">   <span class="k">def</span> <span class="nf">dynamicrange</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
        <span class="p">(</span><span class="n">iH</span><span class="p">,</span> <span class="n">iW</span><span class="p">)</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Dl</span><span class="o">=</span><span class="n">image</span><span class="p">[:,:</span><span class="n">iW</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">DR</span><span class="o">=</span><span class="n">image</span><span class="p">[:,</span><span class="n">iW</span><span class="o">/</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">imagecopy2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">iH</span><span class="p">,</span><span class="n">iW</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">"uint8"</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">iH</span><span class="p">):</span>
        <span class="n">maxv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">Dl</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>
        <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Dl</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span> <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">maxv</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
            <span class="n">imagecopy2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">c</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">Dl</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="n">maxvR</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">DR</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>
        <span class="n">d</span><span class="o">=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">DR</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">maxvR</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
            <span class="n">imagecopy2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">iW</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">DR</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">imagecopy2</span></code></pre></figure>

</div>

<h3 id="detect-lane-pixels-and-fit-to-find-the-lane-boundary">Detect lane pixels and fit to find the lane boundary</h3>
<p>The Image after dynamic thresholding is passed as an argument to ROI function which crops the image leaving out only lane pixel. The ROI image is then perspectively transformed to obtain Bird eye view. The histogram of the lower half of the image is used to get the range of the position of pixels in the image. Then dividing the entire image into n(current n=9) windows. Using the function Your image.nonzero() to get x, y coordinates of non zero pixels is determined. Now x and y coordinate of right and left lane pixels are determined.we use Curve fitting to obtain the polynomial.</p>
<table style="width:100%; border:0px;">
  <tr>
    <th>ROI image</th>
    <th>Bird Eye View</th> 
  </tr>
  <tr>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/ROI_screenshot_07.09.2018.png" width="480px" /></td>
    <td><img src="/Advance_lane_Extraction_In_different_condition/assets/images/BIE_screenshot_07.09.2018.png" width="480px" /></td>
  </tr>
</table>
<div class="code-block"> 

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">ROI</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>   <span class="c"># function to get region of interest in a                           image</span>
    <span class="c">#img=color_filter(img1)</span>
    <span class="n">h</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c">#change the ppoly coordinate according the camera mount</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">200</span> <span class="p">],[</span><span class="n">w</span><span class="p">,</span><span class="mi">200</span><span class="p">],[</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="n">h</span><span class="p">]])</span>
    <span class="c">#define a numpy array with the dimensions of img, but comprised of zeros</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="c">#Uses 3 channels or 1 channel for color depending on input image</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">channel_count</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ignore_mask_color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,)</span> <span class="o">*</span> <span class="n">channel_count</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ignore_mask_color</span> <span class="o">=</span> <span class="mi">255</span>
    <span class="c">#creates a polygon with the mask color</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">([</span><span class="n">shape</span><span class="p">]),</span> <span class="n">ignore_mask_color</span><span class="p">)</span>
    <span class="c">#returns the image only where the mask pixels are not zero</span>
    <span class="n">masked_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_image</span>
<span class="k">def</span> <span class="nf">birdeyeview</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">h</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">200</span> <span class="p">],[</span><span class="n">w</span><span class="p">,</span><span class="mi">200</span><span class="p">],[</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="n">h</span><span class="p">]])</span>
    <span class="n">pts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">h</span><span class="p">]])</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span><span class="n">matrix</span>
<span class="k">def</span> <span class="nf">extract_lanes_pixels</span><span class="p">(</span><span class="n">binary_warped</span><span class="p">):</span>

        <span class="c"># Take a histogram of the bottom half of the image</span>
        <span class="n">m</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">histogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">binary_warped</span><span class="p">[</span><span class="n">m</span><span class="p">:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#plt.plot(histogram)</span>
        <span class="c">#plt.show()</span>
        <span class="c"># Create an output image to draw on and  visualize the result</span>
        <span class="n">out_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">))</span><span class="o">*</span><span class="mi">255</span>
        <span class="c"># Find the peak of the left and right halves of the histogram</span>
        <span class="c"># These will be the starting point for the left and right lines</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">histogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">leftx_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">histogram</span><span class="p">[:</span><span class="n">midpoint</span><span class="p">])</span>
        <span class="n">rightx_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">histogram</span><span class="p">[</span><span class="n">midpoint</span><span class="p">:])</span> <span class="o">+</span> <span class="n">midpoint</span>

        <span class="c"># Choose the number of sliding windows</span>
        <span class="n">nwindows</span> <span class="o">=</span> <span class="mi">9</span>
        <span class="c"># Set height of windows</span>
        <span class="n">window_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nwindows</span><span class="p">)</span>
        <span class="c"># Identify the x and y positions of all nonzero pixels in the image</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">nonzeroy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nonzerox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c"># Current positions to be updated for each window</span>
        <span class="n">leftx_current</span> <span class="o">=</span> <span class="n">leftx_base</span>
        <span class="n">rightx_current</span> <span class="o">=</span> <span class="n">rightx_base</span>
        <span class="c"># Set the width of the windows +/- margin</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c"># Set minimum number of pixels found to recenter window</span>
        <span class="n">minpix</span><span class="o">=</span><span class="mi">50</span>
        <span class="c"># Create empty lists to receive left and right lane pixel indices</span>
        <span class="n">left_lane_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">right_lane_inds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Step through the windows one by one</span>
        <span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwindows</span><span class="p">):</span>
            <span class="c"># Identify window boundaries in x and y (and right and left)</span>
            <span class="n">win_y_low</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">window_height</span>
            <span class="n">win_y_high</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">window</span><span class="o">*</span><span class="n">window_height</span>
            <span class="n">win_xleft_low</span> <span class="o">=</span> <span class="n">leftx_current</span> <span class="o">-</span> <span class="n">margin</span>
            <span class="n">win_xleft_high</span> <span class="o">=</span> <span class="n">leftx_current</span> <span class="o">+</span> <span class="n">margin</span>
            <span class="n">win_xright_low</span> <span class="o">=</span> <span class="n">rightx_current</span> <span class="o">-</span> <span class="n">margin</span>
            <span class="n">win_xright_high</span> <span class="o">=</span> <span class="n">rightx_current</span> <span class="o">+</span> <span class="n">margin</span>
            <span class="c"># Draw the windows on the visualization image</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">out_img</span><span class="p">,(</span><span class="n">win_xleft_low</span><span class="p">,</span><span class="n">win_y_low</span><span class="p">),(</span><span class="n">win_xleft_high</span><span class="p">,</span><span class="n">win_y_high</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">out_img</span><span class="p">,(</span><span class="n">win_xright_low</span><span class="p">,</span><span class="n">win_y_low</span><span class="p">),(</span><span class="n">win_xright_high</span><span class="p">,</span><span class="n">win_y_high</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="c"># Identify the nonzero pixels in x and y within the window</span>
            <span class="n">good_left_inds</span> <span class="o">=</span> <span class="p">((</span><span class="n">nonzeroy</span> <span class="o">&gt;=</span> <span class="n">win_y_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzeroy</span> <span class="o">&lt;</span> <span class="n">win_y_high</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&gt;=</span> <span class="n">win_xleft_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&lt;</span> <span class="n">win_xleft_high</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">good_right_inds</span> <span class="o">=</span> <span class="p">((</span><span class="n">nonzeroy</span> <span class="o">&gt;=</span> <span class="n">win_y_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzeroy</span> <span class="o">&lt;</span> <span class="n">win_y_high</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&gt;=</span> <span class="n">win_xright_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nonzerox</span> <span class="o">&lt;</span> <span class="n">win_xright_high</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Append these indices to the lists</span>
            <span class="n">left_lane_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_left_inds</span><span class="p">)</span>
            <span class="n">right_lane_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">good_right_inds</span><span class="p">)</span>
            <span class="c"># If you found &gt; minpix pixels, recenter next window on their mean position</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_left_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">minpix</span><span class="p">:</span>
                <span class="n">leftx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nonzerox</span><span class="p">[</span><span class="n">good_left_inds</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_right_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">minpix</span><span class="p">:</span>        
                <span class="n">rightx_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nonzerox</span><span class="p">[</span><span class="n">good_right_inds</span><span class="p">]))</span>

        <span class="c"># Concatenate the arrays of indices</span>
        <span class="n">left_lane_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">left_lane_inds</span><span class="p">)</span>
        <span class="n">right_lane_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">right_lane_inds</span><span class="p">)</span>

        <span class="c"># Extract left and right line pixel positions</span>
        <span class="n">leftx</span> <span class="o">=</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]</span>
        <span class="n">lefty</span> <span class="o">=</span> <span class="n">nonzeroy</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]</span> 
        <span class="n">rightx</span> <span class="o">=</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]</span>
        <span class="n">righty</span> <span class="o">=</span> <span class="n">nonzeroy</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]</span> 

        <span class="k">return</span> <span class="n">leftx</span><span class="p">,</span> <span class="n">lefty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="n">righty</span><span class="p">,</span> <span class="n">left_lane_inds</span><span class="p">,</span> <span class="n">right_lane_inds</span>

<span class="k">def</span> <span class="nf">poly_fit</span><span class="p">(</span><span class="n">leftx</span><span class="p">,</span> <span class="n">lefty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="n">righty</span><span class="p">,</span> <span class="n">left_lane_inds</span><span class="p">,</span> <span class="n">right_lane_inds</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">plot</span><span class="p">):</span>  

        <span class="c"># Fit a second order polynomial to each</span>
        <span class="n">left_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">lefty</span><span class="p">,</span> <span class="n">leftx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">right_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">righty</span><span class="p">,</span> <span class="n">rightx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c"># Generate x and y values for plotting</span>
        <span class="n">ploty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">left_fitx</span> <span class="o">=</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span> <span class="o">+</span> <span class="n">left_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">right_fitx</span> <span class="o">=</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ploty</span> <span class="o">+</span> <span class="n">right_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c"># Identify the x and y positions of all nonzero pixels in the image</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">binary_warped</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">nonzeroy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nonzerox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">out_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">,</span> <span class="n">binary_warped</span><span class="p">))</span><span class="o">*</span><span class="mi">255</span>
        <span class="n">out_img</span><span class="p">[</span><span class="n">nonzeroy</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">],</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">left_lane_inds</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">out_img</span><span class="p">[</span><span class="n">nonzeroy</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">],</span> <span class="n">nonzerox</span><span class="p">[</span><span class="n">right_lane_inds</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>

       
        <span class="k">return</span> <span class="n">left_fit</span><span class="p">,</span> <span class="n">right_fit</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">left_fitx</span><span class="p">,</span> <span class="n">right_fitx</span></code></pre></figure>

</div>

<h3 id="warp-the-lane-boundary-back-on-to-original-image">Warp the lane boundary back on to original image</h3>
<p>Now that lane curves are detected we will use cv2.fillPoly(color_warp, np.int_([pts]), (0,255,0)) to fill image along curve. After this step, Image is inverse perspective transformed into original view plane and combined with the original undistorted image.</p>

<div class="code-block">

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">plain_lane</span><span class="p">(</span><span class="n">undist</span><span class="p">,</span> <span class="n">warped</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">left_fitx</span><span class="p">,</span> <span class="n">right_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
        <span class="n">Minv</span> <span class="o">=</span> <span class="n">inv</span> <span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c"># Create an image to draw the lines on</span>
        <span class="n">warp_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">warped</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">color_warp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">warp_zero</span><span class="p">,</span> <span class="n">warp_zero</span><span class="p">,</span> <span class="n">warp_zero</span><span class="p">))</span>
        
        <span class="c"># Recast the x and y points into usable format for cv2.fillPoly()</span>
        <span class="n">pts_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">left_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">]))])</span>
        <span class="n">pts_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">right_fitx</span><span class="p">,</span> <span class="n">ploty</span><span class="p">])))])</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pts_left</span><span class="p">,</span> <span class="n">pts_right</span><span class="p">))</span>
        
        <span class="c"># Draw the lane onto the warped blank image</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">fillPoly</span><span class="p">(</span><span class="n">color_warp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">([</span><span class="n">pts</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="c"># Warp the blank back to original image space using inverse perspective matrix (Minv)</span>
        <span class="n">newwarp</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">color_warp</span><span class="p">,</span> <span class="n">Minv</span><span class="p">,</span> <span class="p">(</span><span class="n">warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">warped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> 
        <span class="c">#newwarp=undistorth(newwarp)</span>
        <span class="c"># Combine the result with the original image</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="n">undist</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newwarp</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
            
        
        <span class="k">return</span> <span class="n">result</span>


 <span class="k">def</span> <span class="nf">render_curvature_and_offset</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">curverad</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>   
        <span class="c"># Add curvature and offset information</span>
        <span class="n">offst_text</span> <span class="o">=</span> <span class="s">'offset: {:.2f}m'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">font</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">offst_text</span><span class="p">,</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">font</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">curverad_text</span> <span class="o">=</span> <span class="s">'curverad: {:.2f}m'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">curverad</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">curverad_text</span><span class="p">,</span> <span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span> <span class="n">font</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">plot</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">rundist_image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rundist_image</span></code></pre></figure>

</div>

<h3 id="result">Result</h3>
<p>The results obtained from dynamic thresholding in both daylight and artificial illumination scenario.</p>
<iframe width="817" height="297" src="https://www.youtube.com/embed/qstuhDxod5s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

<iframe width="817" height="297" src="https://www.youtube.com/embed/3ekDr2XvUK8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  

</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
